# Example generators.yaml

# The solution is used to generate a .ans for each generated .in which doesn't
# yet have a corresponding .ans. If there are generators that don't write a .ans
# file themselves, this must be specified.
# This should read the input from stdin and write to stdout.
#
# Absolute paths are taken relative to the problem root, relative paths are
# taken relative to the generators directory.
#
# TOOLING: may pick a default if not specified, but should raise a warning.
solution: /submissions/accepted/sol.py

# The visualizer is used when no suitable image was generated already.
# This should read {name}.in and/or {name}.ans from the current working
# directory, and write {name}.ext for an extension in:
# .png, .jpg, .svg
#
# TOOLING: may provide a flag to make running this optional, as it can be slow
# and usually isn't required.
visualizer: /visualizers/asy.py {name}

# Optionally, a salt for generating the {seed} variables. Will be prepended to
# the command being run.
random_salt: abcd

# We support three types of generators:
# - Standalone files, like generators/a.cpp, generators/b.py, ..., which will
#   be compiled if required and run the same way as submissions.
# - Directories, like
#   - generators/gen/tree.cpp
#   - generators/gen/lib.h
#   This will be compiled and run the same way as directory validators. Build
#   and run scripts may be used.
# - 'implicit' generators whose dependencies are specified in the generators:
#   key below. The dependencies may refer to any files relative to generators/.
#   The generator will be built and run as if they formed a separate directory.
#   E.g. the first example below would be equivalent to
#   - generators/tree/lib.py
#   - generators/tree/tree.py
#
# When a generator is used as a command to generate a .in file, we first check
# if the name is a key in the generators: dictionary below. If that is the case,
# the corresponding generator is used. If not, we will use the file/directory
# generator in the generator/ directory directly.
generators:
# A generator that depends on two files, lib.py and tree.py, directly in the
# generators directory.
  tree:
    - lib.py
    - tree.py
# Another generator that also depends on the same lib.py.
  graph:
    - lib.py
    - graph.py
# This also works for other languages.
  a:
    - a.h
    - a.cpp
# Single-file generators may be specified, but can also be referred to as
# b.cpp directly.
  b:
    - b.cpp
# It is allowed, but not required, to explicitly list single-file generators
# as well. It is allowed to reuse the same name, but introducing a new name is
# also fine.
  c.py:
    - c.py
    - lib.py

# The data: keyword contains the list of test cases and test data groups.
# Note that this is different from the data/ directory, which is where the keys
# of this top-level data: dictionary will be written.
data:
  # Introduce the `sample` directory.
  sample:
    type: directory
    solution: # empty to disable generating .ans files here
    data:
      1: stdout.py 1  # prints `1` to stdout, which is piped to 1.in

# To indicate a manual testcase, specify it with an empty value.
      2:
# Any key that matches the glob `*.in` is a manual testcase that will be copied
# from the given directory into the target testcase. The given directory
# must not start with a / and will be relative to generators/.
      3: manual_cases/sample/3.in
# Every testcase must be listed.
# TOOLING: may allow this and print a warning.
     #4:

  secret:
    type: directory
    data:

# Types of generator programs.
      01: stdout.py  3   # stdout of the command is written to 01.in.
      02: stdout.cpp 4   # c++ is compiled as for validators
      03: dir 5          # directories are OK as for validators
      04: tree 5         # keys from the global generators: dictionary may also be used.
      05: a 5            # idem

# The entire command is passed through python shlex.shlex.
      06-string: stdout.py "a b"

# The regex \{seed(:[0-9]+)?\} (e.g. {seed} or {seed:1}) anywhere in the argument
# string will be replaced by an integer hash of the entire command in [0, 2^31).
# The regex may match at most once.
# int(hashlib.sha512((random_salt+command).encode('utf-8')).hexdigest(), 16)%(2**31)
# TODO: Should whitespace matter? We could also first shlex the command to
# remove meaningless whitespace. That's also how we should error on identical commands.
      07-random-1:    stdout.py {seed}
     #08-random-1a:   stdout.py {seed}           # It's an error to use the exact same command twice.
      09-random-2:    stdout.py {seed:2}         # Different seed, because of extra `2`
      10-random-3:    stdout.py seed={seed:2}    # Different seed, because command isn't the same.
     #10-random-4:    stdout.py {seed} {seed:2}  # Not allowed because the regex matches twice.

# No key (testcase or testgroup) may be a prefix of another key.
     #01-second: stdout.py 6                     # Collision with rule 01 above.
     #hard_cases_group-01: stdout.py 7           # Collision with hard_cases_group below.

# {name} may be used to reference the current test case name/dictionary key.
#
# Commands are allowed to write files in the current working directory as long
# as they do not overwrite existing files. Files starting with the current
# {name} may always be written to.
# Commands may only read files that they have written themselves.
#
# Any written files matching {name}.ext where ext is a know extension in
# .in, .ans, .hint, .desc, .png, .jpg, ..svg
# will be saved.
#
# In case a program writes {name}.in, stdout will be ignored.
# In case {name}.in is not created, stdout will be used as input.
      12: write_in_and_ans.py {name}


# To override the global/testgroup configuration on a per-testcase basis,
# a dictionary may be used. This allows the solution: and visualizer: keys,
# as well as the input: key which contains the command to execute.
      13_no_visualizer:
        input: large_case_generator.py 1000000
        solution: gnu_multi_precision.cpp   # Some local file in generators/.
        visualizer:                         # Empty to disable the visualizer here.
# TODO: Adding this because we can.
        random_salt: 123



# Introduce a testgroup by adding a dictionary with `type: directory` set.
# The top-level is always assumed to be a directory.
      hard_cases_group:
# TODO: We could drop this because testcase dictionaries need the input: key
# while testgroups need the include: and/or data: keys.
        type: directory

# Directories may contain a testdata.yaml that will be written as specified.
        testdata.yaml:
          on_reject: break
          accept_score: 25
          range: 0 25
          grader_flags: min

# A testgroup may include all cases in another testgroup. All files for each
# testcase in the other testgroup will be symlinked into the current testgroup.
# Nested included testcases are also included here.
#
# This must be a list of testgroups and/or testcases paths relative to data/.
# Testcases must be referred to by their {name}.
#
# You may only include testgroups that come before the current group, either
# earlier in a list or earlier alphabetically in dictionaries.
#
# TODO: How does this interact with numbering? How do we guarantee included
# cases come first?
# include numbered into numbered: OK
# include dict into dict:     error on name collision. How to guarantee they
# come first?
# include numbered into dict: error on name collision. Do we allow this?
# include dict into numbered: error on name collision. Do we allow this?
        include:
          - sample
          - secret/03

# To enable automatic numbering of testcases, data: may also contain a list of
# dictionaries instead of a single dictionary. In this case, testcases and/or
# groups will be numbered in the order they appear, starting at 1. The system
# will determine the required number of digits to use and numbers will be
# zero-padded accordingly, using a dash as separator from the given name (when
# the given name is not empty). All items in a given dictionary will get the
# same number. Use a list of 1-item dictionaries for incremental numbering.
#
# Any testgroup inside a list must contain a list object as data:.
#
# Numbering is per directory. Testcases/testgroups are ordered by the order of lists
# and alphabetical for dictionaries. Numbering is done in pre-order: first
# number the current testgroup, then number everything inside the group, then
# number testcases/testgroups following the current group.
        data:
          - a: stdout.py a
            b: stdout.py b
          - testgroup:
              type: directory
              data:
                - c: stdout.py c
                  d: stdout.py d
# This is forbidden because data: dictionaries may not appear within data: lists.
             #data:
             #  c: stdout.py c
          - e: stdout.py e
          - f: stdout.py f
          - g: stdout.py g
          - h: stdout.py h
          - i: stdout.py i
          - j: stdout.py j
          - k: stdout.py k
          - l: stdout.py l

# The above data: list is equivalent to the map:
       #data:
       #  01-a: stdout.py a
       #  01-b: stdout.py b
       #  02-testgroup:
       #    type: directory
       #    data:
       #      1-c: stdout.py c
       #      1-d: stdout.py d
       #  03-e: stdout.py e
       #  04-e: stdout.py f
       #  05-e: stdout.py g
       #  06-e: stdout.py h
       #  07-e: stdout.py i
       #  08-e: stdout.py j
       #  09-e: stdout.py k
       #  10-e: stdout.py l

# Unknown keys are allowed inside directory dictionaries for tooling-specific
# extensions. This includes both the global scope and explicit directories with type: directory.
unknown_key: tool_specific_config
